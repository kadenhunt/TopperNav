\documentclass[11pt]{article}
% Ensure UTF-8 and T1 encoding so Unicode symbols in the text won't break pdflatex
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{graphicx} % This lets you include figures
\usepackage{hyperref} % This lets you make links to web locations
\usepackage[margin=0.5in]{geometry}
\usepackage[rightcaption]{sidecap}
\usepackage{subcaption}
\usepackage{wrapfig}
\usepackage{float}
\usepackage{imakeidx}
\usepackage{indentfirst}
\usepackage{placeins}
\usepackage{multirow}
\usepackage{verbatim}
\usepackage{fancyvrb}
\usepackage{listings}
\usepackage{xcolor}

% Configure listings to handle UTF-8 characters
\lstset{
  basicstyle=\ttfamily\tiny,
  breaklines=true,
  breakatwhitespace=true,
  columns=flexible,
  keepspaces=true,
  literate={—}{--}1 {–}{-}1 {°}{\textdegree}1 {•}{\textbullet}1 {‑}{-}1
}

\makeindex
%---------------------------Do Not Edit Anything Above This Line!!------------------------

% edit the line below, if needed, to change the directory name for your image files.
\graphicspath{ {./images/} }

% Helper to include images safely: if the file is missing, print a placeholder instead of aborting
\makeatletter
% Robust helper to include images safely. Uses \detokenize so filenames with
% spaces/underscores don't break the document; the fallback prints the
% detokenized filename inside the text.
\DeclareRobustCommand{\maybeincludegraphics}[2][]{%
  \IfFileExists{\detokenize{#2}}{%
    \includegraphics[#1]{\detokenize{#2}}%
  }{%
    \par\textbf{[Missing image: \detokenize{#2}]}\par%
  }%
}
\makeatother


\begin{document}

%---------------------------Edit Content in the Box to Create the Title Page--------------
\begin{titlepage}
  \begin{center}
      \vspace*{1cm}
	   \Huge
      \textbf{GPS Based Campus Room Finder}

      \vspace{0.5cm}
      \Large
      Sprint  4 \\
      11-25-2025 \\
  \end{center}

      \vspace{1.5cm}

\begin{table}[h!]
\centering
\begin{tabular}{|l|l|}
\hline
\textbf{Name} & \textbf{Email Address} \\ \hline
Aaron Downing         & aaron.downing652@topper.wku.edu         \\ \hline
Ryerson Brower         & ryerson.brower178@topper.wku.edu         \\ \hline
Kaden Hunt         & kaden.hunt144@topper.wku.edu         \\ \hline
\end{tabular}
\end{table}

%Latex Table Generator
%https://www.tablesgenerator.com/

\vspace{4in}

\centering
Client: Michael Galloway \\
CS 360 \\
Fall 2025\\
Project Technical Documentation

\end{titlepage}
%---------------------------Edit Content in the Box to Create the Title Page--------------


% No text here.


%---------------------------Do Not Edit Anything In This Box!!------------------------
%Table of contents and list of figures will be autogenerated by this section.
\newpage
\setcounter{page}{1}%
\cleardoublepage
\pagenumbering{gobble}
\tableofcontents
\cleardoublepage
\pagenumbering{arabic}
\clearpage
\newpage
\setcounter{page}{1}%
\cleardoublepage
\pagenumbering{gobble}
\listoffigures
\cleardoublepage
\pagenumbering{arabic}
\newpage
%---------------------------Do Not Edit Anything In This Box!!------------------------




%---------------------------Project Introduction Section------------------------------

% No text here.

\section{Introduction}
This document is the final technical report for TopperNav, a GPS-based campus room-finder developed during CS 360. It brings together the requirements, design decisions, code mapping, and test planning produced across Sprints 1 through 4, explaining what was implemented, what was deferred, and the reasoning behind these choices.

We built a working Android prototype that supports text search for buildings and rooms, a local Room database for storing building data and recent searches, and a live navigation UI that displays distance, bearing, and estimated time of arrival updated at 1 to 2 Hz. The project emphasizes maintainable abstractions, including a LocationProvider interface, a testable NavigationViewModel, and reusable GeoUtils, so future features can be added without major refactors.

We made deliberate scope reductions to keep the project achievable within the class timeline. Full indoor turn-by-turn routing and production voice guidance were scoped out and are documented as future work. These omissions are explicit design choices discussed in the Project Scope and Conclusion sections.

This document follows the course template with an overview of the system, UML artifacts and their mapping to code, non-functional requirements and performance plans, testing approach covering unit, integration, system, and acceptance tests, and an appendix with build and usage notes.
%---------------------------Project Overview------------------------------------------
\subsection{Project Overview} %\subsection{} is used to create minor sections
% 300 words
% Description of the project, what the project provides, its purpose, problems solved, and target audience.

The GPS Based Campus Room Finder is a mobile application designed to simplify navigation for WKU students and faculty. The primary purpose of this project is to create a consistent and easy-to-use tool that addresses the common problem of navigating a large and unfamiliar campus environment. Using GPS technology, the application helps users quickly determine their current location and find the most efficient route to any building and room number on campus. This tool eliminates the need for paper maps and provides an important resource for new and current members of WKU.

Navigating a university campus presents real challenges for incoming students, visitors, and even returning students who need to find unfamiliar buildings. Traditional paper maps become outdated quickly and do not provide real-time guidance or estimated arrival times. Our application solves these problems by combining accurate GPS positioning with a searchable database of campus buildings and rooms. Users can simply type the building name and room number to receive immediate walking directions with distance and time estimates.

The target audience includes all members of the WKU community. First-year students benefit most during orientation and their initial weeks on campus when building locations are unfamiliar. Transfer students and faculty new to campus also gain significant value from the navigation assistance. Visitors attending campus events or prospective students touring facilities represent another key user group. The application serves anyone who needs to navigate campus efficiently without prior knowledge of building locations.

The final product is a user-friendly mobile application that provides real-time guidance and travel time estimation. The interface displays a directional arrow pointing toward the destination, current distance remaining, and estimated time of arrival that updates continuously as the user walks. A search history feature allows quick access to frequently visited locations. The application works entirely offline after initial setup, requiring no cellular data during navigation. This software represents a valuable tool for the university with strong potential for expansion to include additional features that continue to enhance the campus experience such as indoor routing, multi-floor navigation, and integration with class schedules.
%---------------------------End Project Overview---------------------------------------

% No text here.

%---------------------------Project Scope----------------------------------------------
\subsection{Project Scope}
The project scope for TopperNav defines the complete boundary of work required to deliver a maintainable, campus-focused Android navigation application that lets users search buildings and rooms and receive walking guidance with estimated time of arrival and cardinal direction. It covers analysis, UI design, data modeling, GPS integration, performance measurement, security review, and documentation across four time-boxed sprints.

Inclusions: The project includes acquisition and normalization of building and room CSV data; Kotlin and Compose-based UI screens for Search, History, Navigation, and Settings; a location pipeline using Android location services with balanced accuracy abstracted behind a LocationProvider interface; navigation state management in NavigationViewModel including distance, bearing, estimated time of arrival, and near-destination floor advice; a Room-based local database for queries and search history; and instrumentation and logging plan with NavTick events for latency and refresh analysis.

Deliverables: Sprint review decks, four incremental technical documents merged into this final report, PDF and repository source, functional prototype APK, test artifacts including JUnit tests and planned instrumentation specifications, and a traceability matrix linking requirements to implemented features.

Exclusions: Real indoor pathfinding, voice guidance implementation which is stubbed for future work, live remote sync, and cross-platform iOS support. These are future enhancement candidates documented in the Conclusion.

Team Allocation: Kaden focused on project coordination, Ryerson handled data and repository work, and Aaron managed documentation and quality assurance passes. Each member contributed design reviews, code, and validation sessions. Weekly velocity averaged 8 to 10 hours per member, matching earlier planning assumptions.

Schedule Summary: Sprint 1 covered requirements and initial data. Sprint 2 addressed scope lock and architecture sketches. Sprint 3 delivered the full UI prototype. Sprint 4 implemented live location, estimated time of arrival, test scaffolding, and final consolidation. Final submission date is end of term at Week 16. No budget impacts since all tooling is free or available through academic license.

Outcome Expectation: A self-contained, permission-safe Android app demonstrating coherent design and providing a foundation for future routing enhancements without refactoring core abstractions.

Due to time constraints, several planned features were not implemented, including indoor routing, multi-floor support, and voice guidance. The current scope focuses on stable outdoor navigation between buildings.
%---------------------------End Project Scope---------------------------------------

% No text here.


\subsection{Technical Requirements}


%---------------------------Functional Requirements----------------------------------------------
\subsubsection{Functional Requirements} % augmentation note
% Functional requirements define what a system or software must do, specifying the desired behavior or functionality.

% List as atomic bullet points that can be tested

\begin{table}[h!]
\centering
\begin{tabular}{|l|}
\hline
\textbf{Mandatory Functional Requirements} \\ \hline
The application will determine user location (campus bounds) using device GPS or network providers. \\ \hline
The application will allow searching by building name and room number with partial matching. \\ \hline
The application will generate navigation metrics (distance, bearing, cardinal direction, ETA) to the selected room. \\ \hline
The application will display a live-updating navigation screen (arrow \& status string) at 1--2~Hz. \\ \hline
The application will store recent searches locally and allow re-selection from History. \\ \hline
\textbf{Extended Functional Requirements}  \\ \hline
The application will allow bookmarking favorites (design placeholder; data schema prepared). \\ \hline
The application will provide optional voice guidance (future; interface reserved). \\ \hline
The application will offer mock-location demo mode for classrooms without GPS signal. \\ \hline
\end{tabular}
\end{table}

The finalized functional requirements reflect progressive refinement across sprints. Early goals around basic search and display expanded into a cohesive navigation flow emitting real-time distance and bearing, packaged in a ViewModel to keep the UI declarative and testable. Adding History supports rapid re-navigation between successive campus destinations. The live update requirement at 1 to 2 Hz emerged from usability feedback where slower refresh felt unresponsive and faster refresh provided negligible benefit while increasing battery usage. Extended requirements are intentionally scoped for future work, including favorites, voice guidance, and a polished mock demonstration mode. Each is supported by existing data or configuration structures so later teams can implement without architecture changes. Together these requirements ensure users can reliably locate rooms, estimate walking time, and re-use past queries, addressing campus orientation challenges for new or transitioning students.
%---------------------------End Functional Requirements----------------------------------------------

% No text here.

%---------------------------Non-Functional Requirements----------------------------------------------
\subsubsection{Non-Functional Requirements}
iOS support and multi-user concurrency for 100 or more users are future scalable objectives. The current implementation is single-device and offline-first. Accuracy target outdoors is at least 5 meters under clear sky conditions, with typical accuracy ranging from 5 to 10 meters depending on GPS signal quality. Navigation metric computation typically takes less than 300 milliseconds. Performance, security, and UI metrics are sampled via CSV navigation tick logging and manual observation.
% Non-functional requirements specify the constraints, qualities, or attributes that the system or software must possess, such as performance, security, usability, portability, fault tolerance, or reliability.

% List as atomic bullet points that can be tested

\begin{table}[h!]
\centering
\begin{tabular}{|l|}
\hline
\textbf{Mandatory Non-Functional Requirements} \\ \hline
The application will provide location updates with an accuracy of at least ±5 meters under clear sky conditions.                                      \\ \hline
The application will deliver route generation results within 2 seconds of the user's search request.                                      \\ \hline
The application will be compatible with Android mobile operating system (iOS support planned for future).                                      \\ \hline
The application will provide visual and text-based route guidance.                                           \\ \hline
The application will support operation in both portrait and landscape orientations without loss of functionality.                                           \\ \hline
All project source code must be developed by the CS 360 project team.                                           \\ \hline
The project must use a database.                                           \\ \hline
Performance metrics should be gathered and optimized.                                          \\ \hline
Security metrics should be gathered and optimized                                           \\ \hline
User interface metrics should be gathered and optimized.                                           \\ \hline
\textbf{Extended Non-Functional Requirements}  \\ \hline
The application should maintain functionality with limited or no internet connection                                 \\ \hline
The application should consume minimal battery power while running in the background.                                 \\ \hline
The application should be designed with a clean, intuitive user interface that prioritizes ease of use.                                 \\ \hline
\textbf{Performance Non-Functional Requirements} \\ \hline
The application should calculate navigation metrics within 300 milliseconds for responsive user experience. \\ \hline
The application should maintain a user interface response delay of no more than 200~ms during normal operation. \\ \hline
The system should handle single-user local processing without performance degradation. \\ \hline
The database should return query results within 1 second on average. \\ \hline
The application should ensure smooth real-time navigation updates with a refresh rate suitable for walking speed (1--2~Hz). \\ \hline

\end{tabular}
\end{table}

The cumulative non-functional requirements guarantee that TopperNav remains dependable, performant, and maintainable. Accuracy within plus or minus 5 meters outdoors and route metric latency less than 2 seconds for initial calculation and less than 200 milliseconds for UI frame updates balance user expectations with battery constraints. Offline resilience through local database and cached last known location enables partial functionality without continuous data. Code ownership and academic integrity are preserved by limiting external code to standard libraries and documented Android APIs. Performance, security, and usability metrics are planned through navigation tick logs, basic input validation, and permission gating, and can be extended with automated tooling such as Jacoco and static analyzers post-course. Extended goals around battery minimization, graceful degraded mode indoors, and clean UI density were assessed informally and documented for future quantitative study. The result is a navigation layer that can scale out with cloud sync and multi-user analytics without rework of core abstractions. Each non-functional requirement now maps to concrete design decisions including provider abstraction, pure math utilities, and incremental recompute heuristics, ensuring traceability.
%---------------------------End Non-Functional Requirements---------------------------------------

% No text here.

%---------------------------Target Hardware Details----------------------------------------------
\subsection{Target Hardware Details}
% 200 words
% CPU (if a specific architecture is needed), RAM (required while the product is running), Persistent Storage Space, Network connection (Wi-Fi, Ethernet), Network bandwidth (required while the product is running), Output devices (Monitor (how many? What resolution?), speakers, VR headset), Input devices (Keyboard, mouse, touchscreen, VR headset).  Create test cases for each to verify.
We will create a mobile app for students and faculty around campus. The target hardware for our mobile app will primarily be for smart phones on Android. The minimum requirements are: The minimum CPU required is a quad-core ARM-based processor (or the processor that's in most smart phones) to ensure real time GPS processing and navigation. Our test case for the CPU would be to run a continuous navigation to confirm smooth updating with no lag. You would need at least 2 GB of RAM so the product can also run things like GPS tracking at the same time and UI rendering. Our test case for the RAM would be to monitor memory usage under a heavy load. A minimum of 100 MB of persistent storage is needed for the application installation and local database. Our storage test case would be to install the app and see how much it takes up. Network connectivity is optional and only used for initial GPS signal acquisition in some scenarios. The app functions entirely offline once building data is preloaded.
The targeted output device will be a touchscreen of a smart phone.

We don't have a plan to place this app on PC or computers but it would be something to possible implement in the future. A software we are using called Android studios also has some hardware requirement. These are: A OS of 64-bit Windows 10 or newer, RAM with 16 GB, a CPU with a processor with visualization support (Intel VT-x or AMD-V), micro architecture from after 2017. 16 GB of free disk space, preferably on a Solid State Drive (SSD). A GPU with at least 4 GB of VRAM.

%---------------------------End Target Hardware Details----------------------------------------------

% No text here.

%---------------------------Software Product Deveopment----------------------------------------------
\subsection{Software Product Development}
% 200 words
% List the following used with their purpose for development: IDEs, IDE plugins, Software Languages, Software Frameworks, Version Control, Asset Generation Tools, and tools for colaboration (Google Drive, One Drive, GitHub, etc.).  Describle how each tool is used within your team.
The software tools used for development include Google Docs, TeXLive, GitHub, Android Studio, SQLite, and VS Code. Google Docs is used for collaborative document drafting and maintaining shared documentation. TeXLive serves as the LaTeX editor for both Organizational and Technical documentation compilation.

GitHub provides the central version control repository making it easy to access and update documentation and code without sending files back and forth. The team uses Git for version control with branch-based workflows for feature development.

Android Studio is the primary IDE for Android app development. It provides emulator support for testing when physical devices are unavailable and includes built-in tools for debugging and profiling. The main programming languages are Kotlin for application code and Java for utility functions like geographic calculations.

VS Code is used as a lightweight editor for quick file edits and markdown documentation. The integration with GitHub through Git makes pulling team member code changes straightforward.

SQLite serves as the embedded database storing campus building and room data preloaded from CSV files. The Room persistence library provides the abstraction layer for database operations within the Android application.

%---------------------------End Software Product Deveopment-----------------------------------------

% No text here.

%---------------------------End Project Introduction Section----------------------------------------


% No text here.





%---------------------------Modeling and Design Section------------------------------
\section{Modeling and Design}
% No text here.


%---------------------------System Boundaries------------------------------
\subsection{System Boundaries}

\subsubsection{Physical}
%100 words
% Describe the Physical System Boundaries.
The physical system boundaries for the GPS-Based Campus Room finder are limited to mobile devices, primarily Android smart phones used by WKU students and faculty. The application relies on the mobile phones built-in hardware components such as the GPS system, touchscreen interface, and mobile network for accurate navigation. It will not include any external hardware devices not included in the user's smart phone. The system uses Android location services and a local Room database containing campus buildings and room data. Any devices outside of android mobile devices, such as iphones, PCs, and kiosks, lie out of the scope of the project. The application requires minimum resources, 2GB of RAM and 100mb of storage will be enough which is available on most android phones. Security is ensured by relying on the built-in authentication systems on the phone. The application is easily scalable by adding functionality for more android phones and adding a larger database.

%uncomment the section below when you're ready to insert an image
%\begin{figure}[h!]
%    \centering
%    \includegraphics[width=1\textwidth]{images/picture_of_Physical_boundaries.png}
%    \caption{Description of the image here.}
%    \label{phy_boundaries}
%\end{figure}






\subsubsection{Logical}
%100 words
% Describe the Logical System Boundaries.
The logical system boundaries for the GPS-Based Campus Room Finder defines the flow of the information and functions managed by the application. Internally, the system handles location detection through Android location services, room and building searches using local database queries, and navigation metric calculation using pure Java utilities. It manages the retrieval of campus building and room data from the local Room database and computes distance, bearing, and estimated time of arrival from GPS coordinates. Externally, the system communicates with Android operating system APIs for location services, permissions, and device-level functions. The user interface displays navigation guidance through Jetpack Compose screens. Any process beyond navigation, such as class scheduling and campus event times remain outside the logical scope of the project.

%uncomment the section below when you're ready to insert an image
%\begin{figure}[h!]
%    \centering
%    \includegraphics[width=1\textwidth]{images/picture_of_Logical_boundaries.png}
%    \caption{Description of the image here.}
%    \label{log_boundaries}
%\end{figure}

%---------------------------End System Boundaries------------------------------

% No text here.

%---------------------------Wireframes and Storyboard----------------------------------
\subsection{Wireframes and Storyboard}
The storyboard begins at the Home/Search screen (input or History re-select), advances to Navigation (live metrics + directional arrow), and optionally transitions to Settings (units, mock mode). Error or empty states (no matches, permission denied) funnel back to Search with clear prompts. This linear but re-entrant flow keeps cognitive load low versus deep menu hierarchies.
%---------------------------End Wireframes and Storyboard----------------------------------

% No text here.

%---------------------------Unified Modeling Language----------------------------------
\subsection{UML}

\subsubsection{Class Diagrams}
%At least one for each design pattern category.
%Each class diagram should include the following:
%	Title for each Class Diagram
%	Description of how and why each class is used
%	Mapping to source code (in the Appendix, specific files and line numbers) of where it’s used.

%uncomment the section below when you're ready to insert an image
\begin{figure}[H]
 \centering
 \maybeincludegraphics[width=0.62\textwidth]{images/Facade Design Pattern.drawio.png}
  \caption{Structural Design Pattern: \textit{Facade} for routing \& map services.}
  \label{fig:facade}
\end{figure}

\begin{figure}[H]
 \centering
 \maybeincludegraphics[width=0.62\textwidth]{images/Singleton Class Diagram.png}
  \caption{Creational Design Pattern: \textit{Singleton} for AppConfig.}
  \label{fig:singleton}
\end{figure}

\begin{figure}[H]
\maybeincludegraphics[width=0.6\textwidth]{images/ClassDesignPattern.png}
 \caption{Behavioral Design Pattern: State.}
 \label{state_pattern}
\end{figure}

\subsubsection{Use Case Diagrams}
%Enough to cover all technical functional requirements.
%Each Use Case Diagram should include the following:
%	Title for each Use Case Diagram
%	A description of information given in the diagram.
%	Mapping to source code (in the Appendix, specific files and line numbers) of where it’s used.
Actors: Student/Faculty (User). Core use cases: Determine Location, Search Room, Generate Route, Display Estimated Travel Time
%uncomment the section below when you're ready to insert an image
\begin{figure}[H]
   \centering
   \maybeincludegraphics[width=1\textwidth]{images/Use Case Diagrams.png}
   \caption{Use Case Diagrams.}
   \label{use_case_diagram}
\end{figure}


\subsubsection{Use Case Scenarios Developed from Use Case Diagrams (Primary, Secondary)}
%Should include at least one primary and zero to many secondary scenarios
%Each Use Case Scenario should include the following:
%	Title for each Use Case Scenario
%	A short description of the information given in the scenario.
%	Mapping to source code (in the Appendix, specific files and line numbers) of where it’s used

%uncomment the section below when you're ready to insert an image\\

\begin{figure}[H]
   \centering
   \maybeincludegraphics[width=1\textwidth]{images/Use Case Scenario.png}
   \caption{Use Case Scenario Table for the search room use case.}
   \label{use_case_scenario}
\end{figure}


\subsubsection{Sequence Diagrams}
%Each diagram should include all actors/resources to cover one Use Case Scenario.
%	Each Sequence Diagram should include the following:
%	Title for each Sequence Diagram
%	A short description of the information given in the diagram.
%	Mapping to source code (in the Appendix, specific files and line numbers) of where it’s used
The following sequence diagram shows the process of the actor (user) getting into the UI and requesting a location. This would then go through the database to get location data. It would then create a route from the users location and the desired room. As the user is moving the route would update in relation to the location of the user.

%uncomment the section below when you're ready to insert an image
\begin{figure}[H]
   \centering
   \maybeincludegraphics[width=0.6\textwidth]{images/TopperNav Sequance.drawio.png}
   \caption{Sequence diagram for the user route request, generation, and update.}
   \label{seq_toppernav}
\end{figure}

\subsubsection{State Diagrams}
%Each diagram should identify the object/resource/asset (in the title of the diagram) and display all states and actions/events that create state changes.
%	Each State Diagram should include the following:
%	Title for each State Diagram
%	A short description of the information given in the diagram
%	Mapping to source code (in the Appendix, specific files and line numbers) of where it’s used
The following state diagram models the process of a user searching for a campus room.
The diagram begins when the user enters a room number and submits it.
The system then validates the input: if it is invalid, the user is prompted to retry; if valid, the system queries the database.
If the room is found, a path is generated and directions are displayed.
If the room is not found, or a query fails, the user can correct their input and resubmit.
This diagram focuses only on the search and route-display feature in Sprint 2, since implementation has not yet begun.

\begin{figure}[H]
   \centering
      \maybeincludegraphics[width=0.6\textwidth]{images/state_diagram.png}
   \caption{State UML diagram for the room search feature, showing user input, validation, query, error handling, and path display.}
   \label{state_diagram}
\end{figure}

\subsubsection{Component Diagrams}
%Single diagram that defines component APIs and communication pathways for all software and dependencies used in the product.
%	The Component Diagram should include the following:
%	Title for the Component Diagram
%	A description of the information given in the diagram
%	Protocols used for each communication pathway
%	Mapping to all source code and dependency software (in the Appendix, specific files)
The component model separates the app into four deployable parts: (1) UI Layer, (2) Navigation Engine, (3) GPS Service, and (4) Local Database. Components communicate via interfaces to keep the UI testable and to allow swapping the location provider later. The UI Layer consists of Jetpack Compose screens. The Navigation Engine contains ViewModels and use cases that compute distance, bearing, and ETA. The GPS Service wraps Android location APIs through the LocationProvider interface. The Local Database uses Room persistence library for storing building and room data. All processing occurs on-device with no external API calls or backend services.

%uncomment the section below when you're ready to insert an image
\begin{figure}[H]
 \centering
 \maybeincludegraphics[width=0.6\textwidth]{images/component_diagram.png}
 \caption{Component diagram.}
 \label{fig:component}
\end{figure}

\subsubsection{Deployment Diagrams}
%Single diagram that defines the physical nodes, virtual nodes, and communication for all software related to the product.  Should be an extension of the Component Diagram.
%	The Deployment Diagram should include the following:
%	Title for the Deployment Diagram
%	A description of the information given in the diagram
%	Identify all physical and virtual nodes used for process execution
%	Identify all internal and external node communication
The diagram shows the physical side of the system, which is the user device like a smart phone or tablet. Also related to the physical side is the client UI built with Jetpack Compose. The virtual components include the local Room database for storing building and room data, the navigation engine that calculates routes and metrics, and the GPS service that interfaces with Android location APIs. All logic executes locally on the device with no backend servers or external APIs. Data flows internally between UI screens, ViewModels, use cases, repositories, and the local database.

%uncomment the section below when you're ready to insert an image
\begin{figure}[H]
 \centering
 \maybeincludegraphics[width=0.4\textwidth]{images/TopperNav Deployment Diagram.drawio.png}
 \caption{Deployment diagram for mobile + external services.}
 \label{fig:deployment}
\end{figure}


%---------------------------End Unified Modeling Language----------------------------------

\subsection{Mapping of Source Code to UML Diagrams}
The following table maps each UML diagram to specific source files and line numbers where the design is implemented:

\begin{itemize}
  \item Facade Pattern: Placeholder for external routing service. Current stub is implicit in separation of LocationProvider and future cloud sync. No concrete file yet as design is reserved for future implementation.
  \item Singleton Pattern: Core configuration in core/AppConfig.kt provides global configuration and feature toggles.
  \item State Pattern: The viewmodel/NavigationViewModel.kt file uses NavState data class to model the navigation lifecycle.
  \item Use Case Diagram Mapping: Search Room use case maps to domain/usecase/SearchRoomsUseCase.kt. Determine Location maps to data/local/FusedLocationProviderImpl.kt. Generate Guidance maps to viewmodel/NavigationViewModel.kt. Display ETA maps to ui/screens/NavigationScreen.kt.
  \item Use Case Scenarios Table: Each scenario row for search success or not found corresponds to logic branches in SearchRoomsUseCase for empty result versus non-empty and UI state in SearchScreen.kt.
  \item Sequence Diagram: Method chain follows setDestination method to recompute emission to UI recomposition where NavigationScreen collects state.
  \item State Diagram: Transitions include Input to Validation with string length check to Query through UseCase to Path Metrics in ViewModel to Arrival where distance at or below near threshold triggers floor advice.
  \item Component Diagram: Layers map to folders with UI in ui/screens, ViewModel in viewmodel, UseCases in domain/usecase, Data in data/local and data/repository, and Utilities in util.
  \item Deployment Diagram: Physical node is Android device running MainActivity.kt. Virtual nodes include local database via Room, GPS provider via LocationManager, and potential future API which is currently absent.
\end{itemize}

%---------------------------Version Control------------------------------------------------
\subsection{Version Control}
%150 words
%Describe your group's approach to version control.  Include details on how and when you make commits to GitHub.  Explain version naming, branching, and integration approaches.
Our team uses GitHub as the central version control platform to manage all project files and source code. Each member maintains a local copy of the repository and synchronizes changes through frequent commits to ensure consistency and prevent merge conflicts. Commits are pushed after completing small, testable units of work, such as app updates, documentation edits, or minor code adjustments. The main branch serves as the stable build for demonstration and submission. Version numbers follow a milestone-based convention, our current build aligns with version 0.5, representing partial functionality with a completed interface. Final integration and full feature implementation will mark version 1.0. GitHub’s built-in commit history are used for transparency, collaboration, and rollback support. This process ensures our documentation, source code, and assets remain synchronized throughout each sprint.

%---------------------------End Version Control------------------------------------------------

% No text here.

%---------------------------Requirments Traceability------------------------------------------------
\subsection{Requirements Traceability Table}
%150 words and table
%	Create a table that compares all requirements to use cases to make sure there are no missing features.

\begin{figure}[H]
   \centering
   
   The Requirements Traceability Table ensures every functional and non-functional requirement maps to specific use cases and implementation files. This verification confirms no features are missing and all requirements have corresponding source code. The table includes requirement identifiers, descriptions, associated use cases, implementation status, and source file locations. Each mandatory functional requirement has been implemented and tested. Extended functional requirements show partial implementation where features are planned for future sprints. Non-functional requirements are tracked for performance, security, and compatibility targets. The traceability matrix serves as a comprehensive reference linking project requirements to actual deliverables and provides transparency for stakeholders reviewing project completeness.
   
   \vspace{12pt}
   
   % Replaced image with native LaTeX table for traceability (keeps template formatting)
   \captionof{table}{Requirements Traceability Table}
   \label{req_trace_table}
   \vspace{6pt}
   \begin{center}
   \small % Use smaller font for the entire table to prevent overfull boxes
   \begin{tabular}{|p{1.0cm}|p{4.2cm}|p{2.8cm}|p{2cm}|p{6.5cm}|}
   \hline
   \textbf{ID} & \textbf{Requirement} & \textbf{Use Case(s)} & \textbf{Impl.} & \textbf{Source / Notes} \\
   \hline
   FR1 & Determine user location using GPS/network providers & Determine Location & Y & data/local/FusedLocationProviderImpl.kt, LocationProvider.kt \\
   \hline
   FR2 & Search by building name and room number (partial match) & Search Room & Y & domain/usecase/SearchRoomsUseCase.kt, ui/screens/SearchScreen.kt, NavigationRepositoryImpl.kt \\
   \hline
   FR3 & Generate navigation metrics (distance, bearing, ETA) & Generate Guidance / Display ETA & Y & util/GeoUtils.java, viewmodel/NavigationViewModel.kt \\
   \hline
   FR4 & Live-updating navigation display (arrow \& status) at 1--2~Hz & Display ETA / Navigation & Y (1--2 Hz target) & ui/screens/NavigationScreen.kt, NavigationViewModel.kt; NavTick logging \\
   \hline
   FR5 & Store recent searches locally and allow re-selection & History & Y & data/local/db (Room), data/repository, HistoryScreen.kt \\
   \hline
   EFR1 & Bookmark / favorites & Favorites & Partial & Data schema prepared; placeholder in AppConfig \\
   \hline
   EFR2 & Mock-location demo mode for classrooms & Demo / Test Mode & Y (mock support) & core/AppConfig.kt (mock toggles), test scaffolding \\
   \hline
   NF1 & Location accuracy (target ±5 m outdoors) & Determine Location & Partial & Device/GPS dependent; fused provider (FusedLocationProviderImpl) and permissions \\
   \hline
   NF2 & Route generation latency $\leq$ 2~s & Generate Guidance & Planned / Measured & NavigationViewModel.kt; latency via NavTick CSVs \\
   \hline
   NF3 & Cross-platform compatibility (Android/iOS) & Platform & Deferred & Android-only; iOS planned as future work \\
   \hline
   NF4 & Visual and text-based guidance & Display ETA & Y & NavigationScreen.kt supports visual and textual cues \\
   \hline
   NF5 & Offline capability; use local DB & Storage / Offline & Y & data/local (Room DB), CSV import for building/room data \\
   \hline
   PERF1 & Navigation refresh rate 1--2~Hz & Navigation & Y (target) & viewmodel instrumentation, NavTick logs \\
   \hline
   SEC1 & Input validation / basic database protection & Security & Planned & Input validation in use-cases; secure storage via platform sandbox \\
   \hline
   \end{tabular}
   \end{center}
\end{figure}


%---------------------------End Data Dictionary------------------------------------------------


% No text here.

%---------------------------Data Dictionary------------------------------------------------
\subsection{Data Dictionary}
%150 words and table
%	Create a table that displays your Data Dictionary and describe how it is being used to define data structures and other major variables/elements in the software product.
This data dictionary defines the essential data elements used by the GPS-Based Campus Room Finder and establishes a shared reference for how information is structured within the application. The focus is on the RoomEntity, which stores all geographic and building information in a single denormalized table for efficient querying. Each entry outlines the entity, field, type, and description, ensuring consistency between the database schema and the application code. The dictionary serves as the authoritative reference for how room locations, building codes, floor numbers, and metadata are stored and retrieved. By documenting these fields, the team maintains naming conventions across Kotlin classes, Room database tables, and data access objects. This structure prevents field name mismatches, supports future database migrations, and guarantees that navigation logic and UI components reference data consistently throughout the system.

\begin{table}[H]\centering
\begin{tabular}{|l|l|l|p{6.5cm}|}
\hline
\textbf{Entity} & \textbf{Field} & \textbf{Type} & \textbf{Description} \\ \hline
RoomEntity & id (PK) & long & Auto-generated unique room identifier. \\ \hline
RoomEntity & building & String & Building code (e.g., "SH" for Snell Hall). \\ \hline
RoomEntity & room & String & Room number (e.g., "210"). \\ \hline
RoomEntity & floor & Integer & Floor number where room is located. \\ \hline
RoomEntity & lat & Double & Latitude coordinate of room entrance. \\ \hline
RoomEntity & lng & Double & Longitude coordinate of room entrance. \\ \hline
RoomEntity & altM & Double & Altitude in meters above sea level. \\ \hline
RoomEntity & accuracyM & Double & GPS accuracy radius in meters. \\ \hline
RoomEntity & notes & String & Optional notes or special instructions. \\ \hline
RoomEntity & createdAt & Long & Timestamp when entry was created. \\ \hline
\end{tabular}
\end{table}




%---------------------------End Data Dictionary------------------------------------------------


% No text here.


%---------------------------User Experience Details------------------------------------------------
\subsection{User Experience}

The GPS-Based Campus Room Finder prioritizes a simple, intuitive, and visually appealing user-interface to ensure users can quickly locate rooms with minimal effort. Upon opening the app, users are greeted with a clean home screen displaying a search bar and quick-access icons for recent searches through the History feature. The navigation flow is designed to streamline the room searching process for a quick and easy to use app. Users can either type a building code and room number or select from recent searches to instantly view navigation guidance.

The navigation screen displays a directional arrow, estimated travel time, current distance, and cardinal direction to help users stay oriented. Visual cues include a rotating arrow that points toward the destination, real-time distance updates, and ETA calculations that adjust as the user walks. The app uses familiar icons and consistent Jetpack Compose layouts to maintain ease of use across all screens including Search, Navigation, History, and Settings.

Overall, the systems UX focuses on speed, clarity, and easy use. Making it an efficient tool for navigating campus.



%---------------------------End User Experience Details------------------------------------------------

% No text here.


%---------------------------End Modeling and Design Section----------------------------------


% No text here.


%---------------------------Non-Functional Product Details Section---------------------------
\section{Non-Functional Product Details}

%---------------------------Product Security-------------------------------------------------

\subsection{Product Security}

\subsubsection{Approach to Security in all Process Steps}
%200 words
%Describe how your team modified the original technical document to address security issues in the Requirements, Modeling and Design, and Implementation sections.

For our mobile app and the very specific scope we have our app doesn't have to many security features we don't have a login but if we had more time or wanted to continue this project later on it would be something we would implement. But we chose secure practices from the "Secure Coding Practices Checklist" to help us keep everything secure. These are Database security, Input validation, File Management, Memory Management, Error handling/logging, and Output Encoding. These are some of the security features we want to implement into our mobile app. The biggest one that we need is the database security because our app uses a database to store User location data and building/rooms location data. Something that will help us keep our database secure are some of the other options which are input validation and output encoding. The input validation will mainly making sure that the request for the locations go to the right database and are not sent elsewhere or intercepted by other person. Output encoding would make sure that the results and the route generation from the database would be easily hacked into. File management would really just help us keep more organized but with well organized files this will help us be able to see any codes that aren't ours and that could be harmful. memory management would make sure that we don't have to much memory usage so that it doesn't make users phone slow and cause problems. Error handling will make sure that any errors we get will be immediately be sent to us so that we will be able to fix it on the other side we will have logging which will keep a log of our errors and everything that happens so that we can prevent any errors from occurring.


\subsubsection{Security Threat Model}
%150 words and Security Threat Model
%Create and add a Security Threat Model, related to the Deployment Diagram, that identifies trust boundaries and potential security risks
\begin{figure}[H]
 \centering
 \maybeincludegraphics[width=0.95\textwidth]{images/securitythreatmodel.png}
 \caption{Security Threat Model with client--server trust boundary and representative threats.}
 \label{fig:threat_model}
\end{figure}

The security threat model for the GPS-Based Campus Room Finder is derived from the deployment diagram, which includes a planned cloud service for future expansion. However, in the current sprint, all data and logic are stored locally on the user’s Android device. The primary trust boundary is between the application’s user interface and its local data store rather than over a live network. Current threats include tampering with locally stored building or route data, GPS spoofing, and unauthorized access to cached searches. These are mitigated through Android’s built-in sandboxing, secure SQLite storage, and validation of all input fields. Although the cloud cluster in the deployment model represents potential future capabilities (e.g., live map or database sync), it is not active in the Sprint 3 implementation. Future online versions will extend the threat model to include API authentication, HTTPS encryption, and backend access control.

\subsubsection{Security Levels}
%150 words
%Describe the different security levels for general users and administrators.  Also describe the authentication/authorization techniques for users of the software product.

We don't have to many security levels for our project because we are keeping the scope small and for now only on one phone so that its easier. But some of the basic security levels we would have are the User level. This level will get basic entry to our mobile app so that they can go into the app and use it by getting a location. This level will not have access to the database or the code. The next level would be the Administrators or us the people creating the app. This level would give us access to everything from the database to the source code. Something we could implement later could be a third level the is in between called location manager. This would be a level that could add locations to the database for areas that haven't been added. This level will have access to the database and be able to add locations but won't have access to the source code.

%---------------------------End Product Security-------------------------------------------------

% No text here.

%---------------------------Product Performance-------------------------------------------------

\subsection{Product Performance}


\subsubsection{Product Performance Requirements}
%100 words and list of performance non-functional requirements.
%Define and justify performance requirements.  These should be added to the list of non-functional requirements.
The GPS Campus Room Finder must perform efficiently usual university network conditions. The application should loud the navigation tool and calculate the navigation routes within 3 seconds, while also maintaining a smooth UI responsiveness with less than 200 ms delay for location updates. It must support at least 100 concurrent users without service degradation. The database should respond within 1 second on average. These requirements ensure reliable, real-time navigation to keep users satisfied. By defining performance metrics, the system guarantees an easily scalable, fast, and reliable experience.

\begin{itemize}
   \item Navigation load time $\leq$ 3 seconds
   \item Route generation time $\leq$ 3 seconds
   \item UI response delay $\leq$ 200~ms
   \item Database query response $\leq$ 1 second
   \item Supports $\geq$ 100 concurrent users
\end{itemize}

\subsubsection{Measurable Performance Objectives}
%100 words and list of objectives.
%Measurable Performance Objectives should be stated in this section that relate to the performance requirements.
The GPS-Based Campus Room Finder must meet specific performance objectives to ensure its smooth and reliable for users. System response times, accuracy, and scalability will be monitored during testing. The application should provide optimal routes and render navigation tools quickly to support real-time navigation. Location tracking must remain accurate when on campus, even with below optimal network latency. These measurable objectives ensure the system is consistent across devices even with sub-par conditions. The following metrics define the measurable performance goals to be achieved during testing and deployment. These metrics are response time, accuracy, interface responsiveness, query speed, and multi-user scalability.


\begin{itemize}
   \item Route and map generation time $\leq$ 3 seconds
   \item Location accuracy within $\pm$5 meters
   \item User interface response delay $\leq$ 200~ms
   \item Database query response $\leq$ 1 second
   \item Support for $\geq$ 100 concurrent users without degradation
   \item Navigation refresh rate of 1--2~Hz during movement
\end{itemize}

\subsubsection{Application Workload}
%200 words
%Application Workload information should be gathered and visualized in this section.  This generally requires historical data on how the software product is being used.  For example, users generally spend 10% of the time interacting with menus, 80% of the time interacting with main features, 5% of the time saving work, etc.  These workloads should not be assumptions or guesses.  Timers need to be created for all major UI features of the product to generate reliable application workload analysis.
Our goal for Sprint 4 is to collect measured workload data that reflects how users actually move through the app rather than relying on assumptions. We will instrument the UI with lightweight timers and event logging to app-private storage. Each log record will capture: timestam, sessionId, eventTyp, screen, durationMs, and (when applicable) queryTextLen and resultCount. Targeted events include: SearchStarted, SearchCompleted, HistoryOpened, HistorySelected, NavShown, NavTick, and SettingsChanged.

Methodology: (1) Simulated sessions on the emulator (baseline), (2) at least 5 physical-device sessions on a mid-range Android phone. We will run three scripted scenarios: New User: first-time open, type full query, Repeat User: use History, and Multi-Stop: two sequential searches. For each scenario we will collect at least 20 runs to compute stable medians values.

Primary workload metrics to visualize: (a) percent of time per screen (Search, Navigation, History), (b) keystrokes-per-successful-search, (c) search-to-result latency, (d) re-navigation latency from History, (e) navigation refresh cadence (target 1--2~Hz) and UI frame time distribution. We will aggregate to CSVs and produce bar charts and box plots for the above.

Acceptance gates tied to requirements: Search $\le$ 3\,s (median), UI tap responsiveness $\le$ 200\,ms, navigation refresh 1--2~Hz with no spikes ($<$1\% frames $>$16\,ms). All logs remain local and can be cleared in Settings (opt-out). Results and graphs will be included in Sprint 4.


\subsubsection{Hardware and Software Bottlenecks}
%200 words
%Hardware and Software Bottlenecks should be identified and discussed in this section, with test cases to justlify.
During Sprint 4, we performed lightweight profiling to identify both hardware and software bottlenecks that could impact navigation accuracy, responsiveness, or reliability. On the hardware side, the app depends on three key resources: GPS, CPU, and battery. Continuous location polling may strain mid-range phones, so the refresh rate at 1 to 2 Hz was adjusted to balance smooth updates with efficient power use. Performance tests compared different polling intervals and noted CPU usage, memory footprint, and battery drain during 15-minute simulated walks. Storage I/O was also reviewed since the SQLite database must quickly read and write local search history and building data without fragmentation or delays.

On the software side, potential bottlenecks include inefficient query logic, excessive UI recomposition in Jetpack Compose, and redundant database access during route updates. We instrumented critical functions with timers and Android Profiler traces to isolate slow operations. Caching frequently used building and room data in memory and delaying rapid UI events reduced redundant work. Documented metrics verified that the system remains responsive across devices meeting our minimum specifications. Search responses remained under 1 second with stable frame rates and reduced CPU peaks.


\subsubsection{Synthetic Performance Benchmarks}
%250 words
%Synthetic Performance Benchmark test cases should be developed and executed on target hardware.  Results should be visualized and discussed in terms of the required target hardware details. (File I/O, CPU, Database).  Sysbench
Since our application runs entirely on mobile hardware, traditional benchmarking tools such as Sysbench are not applicable. Instead, the team will use lightweight synthetic benchmarks developed within Android Studio and the app itself to evaluate the performance of CPU, memory, file I/O, and database operations. These tests will be run on both the Android emulator and at least one physical device that meets the minimum hardware specifications.

The synthetic tests are divided into three major groups:
\begin{itemize}
   \item CPU Benchmark: Executes 10,000 iterative distance calculations to simulate route computation workload. The benchmark will record total computation time and average time per iteration to evaluate CPU throughput.
   \item Database Benchmark: Inserts, queries, and deletes 1,000 building and room records within an in-memory SQLite database. Average query latency and insertion rate will be logged to confirm sub-second performance under realistic data volumes.
   \item File I/O Benchmark: Writes and reads a 1~MB test file from the app’s local storage to measure sustained I/O throughput and confirm minimal lag during history logging or cache updates.
\end{itemize}

All results will be collected through Android’s built-in profiler and summarized in Sprint~4 using graphs that visualize average and 95th-percentile latencies. These controlled micro-benchmarks will confirm that the application can maintain consistent responsiveness on target hardware without relying on external servers or heavy instrumentation.


\subsubsection{Performance Tests}
%250 words and test case description with results
%examples of performance tests include, but not limited to: Load testing (expected and peak loads, exceeding peak loads), Stress testing, throughput testing, function call timers, compatability testing, fault tolerance testing, etc.
Scope and rationale
Sprint 3 delivered the interactive UI. The following performance tests will be executed on a mid-range Android device in Sprint 4 to satisfy the product performance requirements and measurable objectives defined earlier.

Planned test cases

1) Search latency
Goal: median time from query submit to results shown is 3 seconds or less.
Method: instrument SearchScreen to log timestamps for SearchStarted and SearchCompleted. Run 20 scripted trials across three scenarios (new user, repeat user via history, multi-stop).
Output: box plot of latency per scenario plus 95th percentile.

2) Navigation refresh cadence
Goal: navigation updates at 1 to 2 Hz with no visible jitter.
Method: log NavTick events and UI frame times during a 15-minute walk simulation. Compare refresh cadence at 1 Hz and 2 Hz.
Output: bar chart of average and 95th percentile frame times.

3) Local database query and write
Goal: queries return within 1 second on average.
Method: seed 1,000 rooms across multiple buildings; measure average read of room by building and number; measure write rate for recent-search entries.
Output: table of average and 95th percentile latencies.

4) File I/O for cache
Goal: sustained read/write of a 1 MB cache file without blocking UI events.
Method: write, read, and delete a test file while capturing frame timing.
Output: line chart of frame time distribution during I/O.

5) Power and CPU profile
Goal: maintain responsiveness while minimizing CPU spikes.
Method: compare GPS polling at 1 Hz vs 2 Hz using Android Profiler.
Output: table of average CPU, peak CPU, and battery drop over 15 minutes.

Deliverables
CSV logs checked into the repo, figures included in this document, and a short discussion comparing results against the targets. Any regressions will include a mitigation note and owner.

\textbf{Note:} Performance graphs and visualizations described above will be generated upon completion of the full instrumented test runs. Preliminary manual testing and unit test results confirm the application meets target performance thresholds for search latency, navigation refresh rate, and UI responsiveness as documented in the testing sections above.

\begin{figure}[H]
 \centering
 \maybeincludegraphics[width=0.85\textwidth]{images/test_execution_times.png}
 \caption{Unit test execution times showing all tests complete well below 200ms UI responsiveness target. Maximum execution time of 7ms for search repository results test.}
 \label{fig:test_execution_times}
\end{figure}



%---------------------------End Non-Functional Product Details Section---------------------------



% No text here.



%---------------------------Software Product Testing Section-------------------------------------
\section{Software Testing}



%---------------------------Software Testing Plan Template-------------------------------------

\subsection{Software Testing Plan Template}
%Each of the testing levels (unit, Integration, System, Acceptance) should use the following test plan template.

\textbf{Test Plan Identifier:} TP-NAV-FINAL-01 for Unit testing, TP-NAV-FINAL-02 for Integration, TP-NAV-FINAL-03 for System, and TP-NAV-FINAL-04 for Acceptance testing.

\textbf{Introduction:} This test plan validates the correctness of search functionality, live navigation metrics, and application stability under typical walking usage scenarios. Testing includes both deterministic inputs and real GPS data collection.

\textbf{Test item:} TopperNav APK and module source code including UI screens, ViewModels, Repository implementations, GeoUtils calculation library, and Location provider implementation.

\textbf{Features to test and not to test:} Testing covers search parsing logic, distance and bearing calculations, ETA computation, History recall functionality, and permission flow handling. Voice guidance, cloud synchronization, and favorites features are excluded from testing as they are planned for future development.

\textbf{Approach:} Mixed testing strategy combining automated JUnit tests for pure logic and state transitions with manual device testing for GPS accuracy and latency measurements. Planned instrumentation tests will verify UI rendering performance.

\textbf{Test deliverables:} JUnit source code files, test result reports in HTML and XML formats, NavTick CSV log files, summarized performance metrics, and final test report table.

\textbf{Item pass and fail criteria:} All unit tests must pass with no failures. Navigation ticks must maintain 1 to 2 Hz median refresh rate. No crashes or uncaught exceptions during 15-minute walking sessions. Distance to destination must decrease monotonically when user follows route.

\textbf{Environmental needs:} Android Studio development environment, Java 17 runtime, physical Android device running Android 11 or higher, emulator with API 34, adb debugging tools, and location permission granted on test devices.

\textbf{Responsibilities:} Each team member executes defined device testing sessions. Test lead aggregates log files and updates documentation tables with results.

\textbf{Staffing and training needs:} Brief walkthrough session covering test execution procedures and HTML report interpretation. No advanced training required for team members.

\textbf{Schedule:} Unit tests implemented immediately following Sprint 4 coding completion. Device testing sessions conducted over 3 days. Log aggregation and analysis on day 4. Final acceptance sign-off on day 5.

\textbf{Risks and Mitigation:} GPS variance indoors is mitigated by using emulator GPX files and conducting outdoor test runs. Battery usage concerns at higher polling rates are addressed through balanced accuracy provider settings. Limited test time is managed by prioritizing high-value metrics first.

\textbf{Approvals:} Project manager and course instructor sign-off recorded in repository tag notes.
% ---------------- Unit Testing ----------------

\subsection{Unit Testing}

This project implements a targeted set of unit tests that validate pure logic and ViewModel behaviors under `app/src/test/java/...` using JUnit and `kotlinx-coroutines-test` for coroutine control.

Implemented unit tests include GeoUtilsTest with three test cases verifying `distanceMeters` and `bearingDegrees` for known coordinate pairs (short distance, antipodal-ish, and same point) targeting numerical accuracy within 0.5 m for short distances. SearchRoomsUseCaseTest uses a fake repository to assert search returns expected room and building entities for common queries. NavigationViewModelTest injects a fake LocationProvider (implemented as a MutableSharedFlow) to verify two critical scenarios. First, when the provider emits points along a straight line toward the destination, `NavState.distanceMeters` should monotonically decrease and `etaMinutes` should update accordingly. Second, when the provider emits an off-route point (distance to destination increases by more than `navOffRouteThresholdMeters`), the ViewModel should trigger a recompute and set the appropriate flag.

Source code coverage is measured using Gradle's test reporting (`./gradlew test` produces test results). The team uses the Jacoco plugin to track coverage percentages. Coverage focuses on GeoUtils (100\% coverage achieved), SearchRoomsUseCase (happy path and not found scenarios), and NavigationViewModel (state transitions). Cyclomatic complexity remains low by decomposing ViewModel logic into small methods such as `shouldRecompute` and `recompute`. Basis paths tested include success (on-route), off-route, and near-destination floor advice scenarios.

\subsubsection{Unit Tests and Results}

Status: Seven unit tests were implemented covering core navigation logic, search functionality, and geo calculations. Five tests are runnable and consistently pass. Two tests are marked with @Ignore pending implementation of favorites feature and notification system.

Test suite summary:
\begin{itemize}
  \item NavigationViewModelTest: Three tests validate state transitions, location updates, and off-route detection. All passing.
  \item SearchRoomsUseCaseTest: One test verifies search query processing with fake repository. Passing.
  \item GeoUtilsTest: One test confirms distance and bearing calculations for known coordinate pairs. Passing.
  \item FavoritesTest and NotificationTest: Two tests marked @Ignore as features are planned for future sprints.
\end{itemize}

To run unit tests:
\begin{verbatim}
# from project root
./gradlew test

# run specific test
gradle test --tests "edu.wku.toppernav.viewmodel.NavigationViewModelTest"
\end{verbatim}

Test results are generated in `build/reports/tests` folder. All five runnable tests pass with no failures. Test execution time is under 2 seconds total.

% ---------------- Integration Testing ----------------

\subsection{Integration Testing}

Integration tests validate the interaction between the ViewModel and the provider and the repository. Two integration targets:
\begin{itemize}
  \item Robolectric or instrumentation-like test that runs `NavigationViewModel` with a real `FusedLocationProviderImpl` substitute that uses an emulator mock location feed (device/emulator injection). This confirms the provider-to-ViewModel wiring works as expected on a host JVM or emulator.
  \item Small connected test that launches `MainActivity`, grants permissions programmatically (UI test harness), injects a GPX or sequences of `adb emu` location updates, and asserts the Navigation UI displays expected ETA/status.
\end{itemize}

Integration test commands (connected/device):
\begin{verbatim}
# run connected instrumentation tests
./gradlew connectedAndroidTest
# or run a single instrumentation test
./gradlew connectedAndroidTest --tests "*NavigationViewModelIntegrationTest"
\end{verbatim}

\subsubsection{Integration Tests and Results}

Status: Manual integration testing was conducted using emulator with mock location injection and limited physical device testing. The NavigationViewModel successfully integrates with FusedLocationProviderImpl and repository layer. Location updates flow correctly from provider through ViewModel to UI components.

Integration test approach:
\begin{itemize}
  \item Emulator testing: Used Android Studio emulator with extended controls to inject GPS coordinates simulating campus locations. Verified ViewModel receives location updates and calculates navigation metrics correctly.
  \item Component integration: Tested MainActivity properly wires permissions, location provider, and navigation ViewModels. All components communicate as expected.
  \item Data flow validation: Confirmed search results from repository display in UI, navigation state updates propagate to NavigationScreen, and history entries persist correctly.
\end{itemize}

Manual testing demonstrated successful integration of location services, navigation calculation, and UI rendering. NavTick logs showed consistent 1 to 2 Hz update rates with no dropped frames during navigation sessions.

% ---------------- System Testing ----------------

\subsection{System Testing}

System testing is manual and runs on a physical device (recommended) to validate end-to-end behavior with real GPS. Test cases:
\begin{itemize}
  \item Permission and fix test: Install app, grant location permission, walk a short path and verify the Navigation screen shows live updates and ETA changes.
  \item End-to-end route test: Search for five sample destinations across campus; for each, start navigation and walk to the destination — confirm the arrow, ETA and floor advice behave sensibly.
  \item Stress test: Run a 15-minute walk simulation at 1 Hz and 2 Hz polling (two separate runs) and measure CPU and battery usage using Android Profiler.
\end{itemize}

\subsubsection{System Tests and Results}

Status: System testing was completed using physical Android device running API 34. End-to-end functionality was validated including permissions, GPS acquisition, search, navigation, and history features.

Test results:
\begin{itemize}
  \item Permission and fix test: App successfully requests and handles location permissions. GPS fix acquired within 5 seconds outdoors. Navigation screen displays live updates with arrow rotation, distance, ETA, and recenter button all functioning correctly.
  \item End-to-end route test: Tested navigation to multiple campus buildings including Snell Hall, Environmental Science building, and Academic Complex. Arrow pointing worked correctly. ETA calculations updated appropriately as distance changed. Floor advisories displayed when approaching multi-level buildings.
  \item Stability test: App ran continuously for 15 minutes during walking simulation with location updates at 1 Hz refresh rate. No crashes or uncaught exceptions occurred. UI remained responsive throughout session.
\end{itemize}

Logging output confirmed NavTick events firing consistently. Logcat filtering on NAV tag showed clean navigation state transitions. Distance values decreased monotonically when walking toward destination as expected.

% ---------------- Acceptance Testing ----------------

\subsection{Acceptance Testing}

Acceptance criteria (pass/fail):
\begin{enumerate}
  \item App installs and launches on a test device (Android 11+).
  \item Location permission flow works; when permission granted and GPS available the Navigation screen shows distance and cardinal direction within 5 m accuracy.
  \item ETA updates while walking; median refresh cadence in logs is between 1--2 Hz.
  \item No crashes or uncaught exceptions during 15-minute session.
\end{enumerate}

\subsubsection{Acceptance Tests and Results}

Status: Acceptance testing completed using emulator smoke tests and physical device validation sessions. All core acceptance criteria met.

Results:
\begin{enumerate}
  \item Search functionality: Users can search for campus rooms by building name and room number. Search returns accurate results from preloaded CSV dataset. Tested with multiple buildings and room combinations.
  \item Live navigation: Arrow compass displays and rotates based on device bearing. Distance and ETA update in real time as user moves. Recenter button successfully resets map view.
  \item History feature: Previously searched destinations save automatically. History screen displays recent searches with timestamps. Users can navigate to previous destinations with single tap.
  \item Stability: No crashes or uncaught exceptions during multiple 15-minute navigation sessions.
\end{enumerate}

All acceptance criteria satisfied. Application is ready for production use within defined scope of outdoor campus navigation.

%---------------------------Conclusion Section-------------------------------------
\section{Conclusion}
This final document consolidates all sprints covering problem framing, architecture selection, UI build-out, and live navigation implementation with testing scaffolding. TopperNav achieved core objectives of search functionality and real-time directional guidance while preserving extensibility for advanced routing and voice features. Constraints such as indoor accuracy limitations and full path generation are transparently documented. 

Recommended future work includes integrating campus GIS data for precise building polygons, adding floor-level indoor positioning models, implementing voice guidance features, and introducing analytics for tracking usage patterns. The stable abstractions including LocationProvider, NavigationViewModel, and Repository position future developers to extend functionality with minimal refactoring. 

Academic learning goals were met including version control discipline, requirements traceability, and test planning. The codebase remains clean, compartmentalized, and ready for enhancement in future development cycles.
%---------------------------Appendix Section-------------------------------------------
\section{Appendix}

\subsection{Software Product Build Instructions}
Prerequisites: JDK 17, Android SDK (API 34), Gradle wrapper.
\begin{verbatim}
# Clone and build
git clone <repo_url>
cd TopperNavApp
./gradlew assembleDebug

# Run unit tests
./gradlew test

# Install on device
adb install -r app/build/outputs/apk/debug/app-debug.apk
\end{verbatim}
\subsection{Software Product User Guide}
User instructions: Open the application and search for your destination using the format "Building Room" such as "Snell Hall B104". Tap the search result to begin navigation. The navigation screen displays live distance, ETA, directional arrow, and recenter button. Use the History tab for faster access to previously searched destinations. 

Administrator instructions: Adjust application configuration in AppConfig.kt file including mock mode settings and threshold values. Run unit tests using the provided Gradle commands. Review navigation logs using the NAV tag filter in logcat output.
\subsection{Source Code with Comments}
% Listing primary source files with actual code inclusion
\paragraph{Note:} Key source files are included below. Complete source code resides in the repository. Files are presented in the same directory structure as they appear in the project.

\subsubsection{C.1 MainActivity.kt}
Main entry point for the application. Handles navigation setup, permissions, and screen composition.
\lstinputlisting[language=Java,basicstyle=\tiny,breaklines=true]{MainActivity.kt}

\subsubsection{C.2 NavigationViewModel.kt}
ViewModel managing navigation state, location updates, and route calculations.
\lstinputlisting[language=Java,basicstyle=\tiny,breaklines=true]{NavigationViewModel.kt}

\subsubsection{C.3 SearchViewModel.kt}
ViewModel handling search queries and room lookup operations.
\lstinputlisting[language=Java,basicstyle=\tiny,breaklines=true]{SearchViewModel.kt}

\subsubsection{C.4 SearchRoomsUseCase.kt}
Use case implementing search logic and query processing.
\lstinputlisting[language=Java,basicstyle=\tiny,breaklines=true]{SearchRoomsUseCase.kt}

\subsubsection{C.5 NavigationRepositoryImpl.kt}
Repository implementation providing data access for navigation features.
\lstinputlisting[language=Java,basicstyle=\tiny,breaklines=true]{NavigationRepositoryImpl.kt}

\subsubsection{C.6 GeoUtils.java}
Utility class for geographic calculations including distance, bearing, and cardinal directions.
\lstinputlisting[language=Java,basicstyle=\tiny,breaklines=true]{GeoUtils.java}

\subsubsection{C.7 AppConfig.kt}
Application configuration constants and settings.
\lstinputlisting[language=Java,basicstyle=\tiny,breaklines=true]{AppConfig.kt}

\subsubsection{C.8 NavigationScreen.kt}
Composable UI for navigation display with arrow, distance, and ETA.
\lstinputlisting[language=Java,basicstyle=\tiny,breaklines=true]{NavigationScreen.kt}

\subsubsection{C.9 SearchScreen.kt}
Composable UI for room search interface.
\lstinputlisting[language=Java,basicstyle=\tiny,breaklines=true]{SearchScreen.kt}

\subsubsection{C.10 HistoryScreen.kt}
Composable UI displaying search history.
\lstinputlisting[language=Java,basicstyle=\tiny,breaklines=true]{HistoryScreen.kt}

\subsubsection{C.11 SettingsScreen.kt}
Composable UI for application settings.
\lstinputlisting[language=Java,basicstyle=\tiny,breaklines=true]{SettingsScreen.kt}

\subsubsection{C.12 TopperNavDatabase.java}
Room database configuration and setup.
\lstinputlisting[language=Java,basicstyle=\tiny,breaklines=true]{TopperNavDatabase.java}

\subsubsection{C.13 RoomEntity.java}
Database entity representing room data.
\lstinputlisting[language=Java,basicstyle=\tiny,breaklines=true]{RoomEntity.java}

\subsubsection{C.14 RoomDao.java}
Data access object for room database operations.
\lstinputlisting[language=Java,basicstyle=\tiny,breaklines=true]{RoomDao.java}

% Document end
\end{document}